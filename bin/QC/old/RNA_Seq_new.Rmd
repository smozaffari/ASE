---
title: "RNAseq_QC_v19"
author: "Sahar Mozaffari"
date: "3/26/2017"
output:
  pdf_document: default
  html_document: default
---


R Markdown for RNA-seq data

##Genecount matrix:
* genes in rows, individuals/samples by lane and flowcell in columns

```{r Genecountmatrix, echo=FALSE}
library(plyr)
library(dplyr)
count <- read.table("~/star_overhang_v19_genecount_withsex", check.names = F)
count[1:5,1:3]
```
* There are a total of $`r dim(count)[1]-5`$ genes and $`r dim(count)[2]`$ samples

##Covariates
* covariate file has number of reads from total, maternal, and paternal; flowcell, findiv, lane, and adaptor index

```{r sampleswaps, echo = FALSE}

colnames(count)[which(colnames(count)=="9_106451_lane_4")] <- "9_106581_lane_4"
colnames(count)[which(colnames(count)=="9_106451_lane_5")] <- "9_106581_lane_5"

colnames(count)[which(colnames(count)=="5_106581_lane_3")] <- "5_106451_lane_3"
colnames(count)[which(colnames(count)=="5_106581_lane_4")] <- "5_106451_lane_4"

colnames(count)[which(colnames(count)=="7_160591_lane_7")] <- "7_106972_lane_7"
colnames(count)[which(colnames(count)=="7_160591_lane_8")] <- "7_106972_lane_8"

colnames(count)[which(colnames(count)=="7_106952_lane_7")]  <- "7_160591_lane_7"
colnames(count)[which(colnames(count)=="7_106952_lane_8")]  <- "7_160591_lane_8"

count[,which(colnames(count)=="7_106972_lane_7")]  <- NULL
count[,which(colnames(count)=="7_106972_lane_8")]  <- NULL

count[,which(colnames(count)=="7_158841_lane_4")] <- NULL
count[,which(colnames(count)=="7_158841_lane_5")] <- NULL

count[,which(colnames(count)=="11_108211_lane_3")]  <- NULL
count[,which(colnames(count)=="11_108211_lane_4")]  <- NULL

count[,which(colnames(count)=="4_160462_lane_1")]  <- NULL
count[,which(colnames(count)=="4_160462_lane_2")]  <- NULL


count[,which(colnames(count)=="11_110432_lane_3")]  <- NULL
count[,which(colnames(count)=="11_110432_lane_4")]  <- NULL


```



```{r lane, echo=FALSE}
#File that has flowcell, lane & adaptor index
laneindex <- read.table("~/li_6_v19")
colnames(laneindex) <- c("Flowcell", "FINDIV", "Lane", "Adaptor_index")

```

```{r sampleswaps2, echo = FALSE}

laneindex[which(laneindex$Flowcell==5 & laneindex$FINDIV==106581 & laneindex$Lane==3),"FINDIV"] <- 106451
laneindex[which(laneindex$Flowcell==5 & laneindex$FINDIV==106581 & laneindex$Lane==4),"FINDIV"] <- 106451

laneindex[which(laneindex$Flowcell==9 & laneindex$FINDIV==106451 & laneindex$Lane==4),"FINDIV"] <- 106581
laneindex[which(laneindex$Flowcell==9 & laneindex$FINDIV==106451 & laneindex$Lane==5),"FINDIV"] <- 106581

laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==160591 & laneindex$Lane==7),"FINDIV"] <- 106972
laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==160591 & laneindex$Lane==8),"FINDIV"] <- 106972

laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==106952 & laneindex$Lane==7),"FINDIV"] <- 160591
laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==106952 & laneindex$Lane==8),"FINDIV"] <- 160591


laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==158841 & laneindex$Lane==4),"FINDIV"] <- 158471
laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==158841 & laneindex$Lane==5),"FINDIV"] <- 158471

remove <- c(which(laneindex$Flowcell==11 & laneindex$FINDIV==108211 & laneindex$Lane==3),
            which(laneindex$Flowcell==11 & laneindex$FINDIV==108211 & laneindex$Lane==4),
            which(laneindex$Flowcell==4 & laneindex$FINDIV==160462 & laneindex$Lane==1),
            which(laneindex$Flowcell==4 & laneindex$FINDIV==160462 & laneindex$Lane==2),
            which(laneindex$Flowcell==11 & laneindex$FINDIV==110432 & laneindex$Lane==3),
            which(laneindex$Flowcell==11 & laneindex$FINDIV==110432 & laneindex$Lane==4),
            which(laneindex$Flowcell==7 & laneindex$FINDIV==106972 & laneindex$Lane==7),
            which(laneindex$Flowcell==7 & laneindex$FINDIV==106972 & laneindex$Lane==8))

laneindex <- laneindex[-remove,]

```



```{r covs, echo=FALSE}
###Merged covariate file with total reads
cov<- c()
fcmap <- c()

#fix 11 and 1 - 2/1 samples lines didn't work
for (i in 1:11) {
  fcreads <- read.table(paste("~/new_FC_",i,"_v19",sep=""))
  fcreads <- cbind(fcreads,
                   FC_findiv_lane=c(paste(i, fcreads$V1, sep="_")))
  fcmap <- rbind(fcmap, fcreads)
}

  colnames(fcmap)[1:7] <- c("findiv_lane", "beforeWASP", "afterWASPwithXY", "afterWASP", "Unknown", "Maternal", "Paternal")
  fccount <- count[,which(colnames(count)%in%fcmap$findiv_lane)]
  findiv <- sapply(strsplit(colnames(fccount), "_"), "[", 1)
  lane <- sapply(strsplit(colnames(fccount), "_"), "[", 3)

fcmap <- data.frame(fcmap, stringsAsFactors=FALSE)
fcmap$FC_findiv_lane <- as.character(fcmap$FC_findiv_lane)
fcmap[which(fcmap$FC_findiv_lane=="9_106451_lane_4"), "FC_findiv_lane"] <- "9_106581_lane_4"
fcmap[which(fcmap$FC_findiv_lane=="9_106451_lane_5"), "FC_findiv_lane"] <- "9_106581_lane_5"

fcmap[which(fcmap$FC_findiv_lane=="5_106581_lane_3"), "FC_findiv_lane"] <- "5_106451_lane_3"
fcmap[which(fcmap$FC_findiv_lane=="5_106581_lane_4"), "FC_findiv_lane"] <- "5_106451_lane_4"

fcmap[which(fcmap$FC_findiv_lane=="7_160591_lane_7"), "FC_findiv_lane"] <- "7_106972_lane_7"
fcmap[which(fcmap$FC_findiv_lane=="7_160591_lane_8"), "FC_findiv_lane"] <- "7_106972_lane_8"

fcmap[which(fcmap$FC_findiv_lane=="7_106952_lane_7"), "FC_findiv_lane"]  <- "7_160591_lane_7"
fcmap[which(fcmap$FC_findiv_lane=="7_106952_lane_8"), "FC_findiv_lane"]  <- "7_160591_lane_8"

fcmap[which(fcmap$FC_findiv_lane=="7_158841_lane_4"), "FC_findiv_lane"] <- "7_158471_lane_4"
fcmap[which(fcmap$FC_findiv_lane=="7_158841_lane_5"), "FC_findiv_lane"] <- "7_158471_lane_5"

remove <- c(which(fcmap$FC_findiv_lane=="7_106972_lane_7"),
            which(fcmap$FC_findiv_lane=="7_106972_lane_8"),
            which(fcmap$FC_findiv_lane=="11_108211_lane_3"),
            which(fcmap$FC_findiv_lane=="11_108211_lane_4"),
            which(fcmap$FC_findiv_lane=="4_160462_lane_1"),
            which(fcmap$FC_findiv_lane=="4_160462_lane_2"),
            which(fcmap$FC_findiv_lane=="11_110432_lane_3"),
            which(fcmap$FC_findiv_lane=="11_110432_lane_4"))
fcmap <- fcmap[-remove,]
#fcmap$FC_findiv_lane <- as.factor(fcmap$FC_findiv_lane)
#fcmap$FC_findiv_lane <- as.character(fcmap$FC_findiv_lane)
cc <- ldply(strsplit(fcmap$FC_findiv_lane,  "_"))[,2:4]
fcmap$findiv_lane<- paste(cc$V2, cc$V3, cc$V4, sep="_")
  
fcmap$FC_findiv_lane <- as.factor(fcmap$FC_findiv_lane)
laneindex <- cbind(laneindex, 
                   FC_findiv_lane =c(paste(laneindex$Flowcell,
                                           laneindex$FINDIV, 
                                           "lane",
                                           laneindex$Lane,
                                           sep="_")))


cov <- merge(fcmap, laneindex, by="FC_findiv_lane")
head(cov[,-c(2,3,5,6)])

```


##Number of lanes with enough reads, before combining replicates
```{r reads, echo=FALSE, fig.height=3, fig.width=10}
extra.htseq.output <-count[23368:23373,]
res <- count[-c(23368:23373),]
enough.reads <- cov$afterWASPwithXY>10000000
table(enough.reads)
CS=colSums(res)
barplot(sort(CS), ylim=c(0, 40000000), main="Total mapped read counts")
abline(h=5000000, col="red")
text(50,1e07, "5,000,000", col="red")
```
*  Before combining replicates, $`r length(which(enough.reads))`$ out of total $`r length(enough.reads)`$ have more than 10 million reads

* The distribution of Counts Per Million:

```{r CPM, echo=FALSE, fig.height=5, fig.width=10}
counts1 = res+1
CPM_beforesumlane = apply(counts1, 2, function(x) (x*1000000)/sum(x))
hist(log2(CPM_beforesumlane), main = "CPM")

```

##Sexcheck
###Sex assigned by ratio of XIST to EIF1AY gene

```{r sex, echo=FALSE, fig.height=3, fig.width=10}
sexRatio = log2(res["XIST",]+1) - log2(res["EIF1AY",]+1)
# if this is > 0, Female, < 0, male based on expression
callSex= ifelse(sexRatio >0, "F", "M")
table(callSex)
```

* According to expression of sex genes, there are $`r length(which(callSex=="F"))`$ females and $`r length(which(callSex=="M"))`$ males.


```{r gender, echo=FALSE}
###Actual gender, 1 = Male, 2 = Female
findivs <- sapply(strsplit(colnames(res), "_"), "[", 2)
names(sexRatio) <- findivs
gender <- sapply(findivs, function(x) substr(x, nchar(x), nchar(x)))
table(gender)
plot( as.factor(gender), unlist(sexRatio), ylab = "log2(XIST)- log2(EIF1AY)", main = "Expression of gender assigning genes, vs gender")
#colnames(callSex) <- names(gender)


```
* There are supposed to be: $`r length(which(callSex=="2"))`$ females and $`r length(which(callSex=="1"))`$ males.
* The samples misassigned are: $`r sexRatio[which((callSex=="F")&gender==1)]`$ 

#Combining technical replicates
* gene count matrix combined across lanes/flowcells so that each individual has one sum value of gene expression for each gene

```{r combinelanes1, echo=FALSE}
#Combining gene count matrix
beforesumlane <- res
res.matrix<- as.matrix(res)
findivs <- sapply(strsplit(colnames(res.matrix), "_"), "[", 2)
colnames(res.matrix) <- findivs
nms <- colnames(res.matrix)
aftersumlane_mismatch <- res.matrix %*% sapply(unique(nms), "==", nms)
aftersumlane<- aftersumlane_mismatch[,order(colnames(aftersumlane_mismatch))]
aftersumlane[1:5,1:5]
```

* combine total number of read covariate value

```{r combinelanes2, echo=FALSE, fig.height=3, fig.width=10}

#Combining covariates - for reads only. 
beforesumlanecov <- cov
findivs <- sapply(strsplit(as.character(cov$findiv_lane), "_"), "[", 1)
combinecov <- as.matrix(t(cov[,3:8]))
colnames(combinecov) <- findivs
nms <- colnames(combinecov)
aftersumlanecov_mismatch <- as.data.frame(t(combinecov %*% sapply(unique(nms), "==", nms)))
#dim(aftersumlanecov)
aftersumlanecov<- aftersumlanecov_mismatch[order(rownames(aftersumlanecov_mismatch)),]
aftersumlanecov[1:5,c(2,4:6)]

#enough.reads <- aftersumlanecov$afterWASPwithXY>10000000
#table(enough.reads)
#after2<-aftersumlane[,enough.reads]
#after2 <- aftersumlane

CS=colSums(aftersumlane)
barplot(sort(CS), ylim=c(0, 100000000), main="Total mapped read counts")
abline(h=6000000, col="red")
text(50,2e07, "6,000,000", col="red")

```


```{r toofewreads, echo=FALSE, fig.height=5, fig.width=10}
toofewreads <- rownames(aftersumlanecov[which(aftersumlanecov$afterWASPwithXY<10000000),])
```

* The distribution of Counts Per Million after combining replicates:

```{r CPMaftercombine, echo=FALSE, fig.height=5, fig.width=10}
counts1 = aftersumlane+1
CPM_aftersumlane = apply(counts1, 2, function(x) (x*1000000)/sum(x))
hist(log2(CPM_aftersumlane), main = "CPM")
```

##Checking sex after combining replicates

```{r genderaftercombine, echo=FALSE}
head(aftersumlane["XIST",1:5])
sexRatio = log2(aftersumlane["XIST",]+1) - log2(aftersumlane["EIF1AY",]+1)
# if this is > 0, Female, < 0, male based on expression
callSex= ifelse(sexRatio >0, "F", "M")
table(callSex)

findivs <- colnames(aftersumlane)
names(sexRatio) <- findivs
gender <- sapply(findivs, function(x) substr(x, nchar(x), nchar(x)))
table(gender)
plot(as.factor(gender), sexRatio, ylab = "log2(XIST)- log2(EIF1AY)", main = "Expression of gender assigning genes, vs gender")
wrongsex <- sexRatio[c(which((callSex=="F") &gender==1), which((callSex=="M")&gender==2))]
wrongsex
a <- names(wrongsex[abs(wrongsex)>1])
a
largesex<- which(abs(wrongsex)>5)
largesex
```

* There are supposed to be: $`r length(which(callSex=="F"))`$ females and $`r length(which(callSex=="M"))`$ males.
* The samples misassigned are: $`r names(sexRatio[which((callSex=="F")&gender==1)])`$ 


###These $`r length(wrongsex)`$ individuals have wrong assigned sex- last $`r length(largesex)`$ have quite a large error - remove `r a` from data

#Removing X and Y chromosome (and mitochondrial) genes --(and genes not expressed in anyone)--
```{r removesexcheck, echo=FALSE}
#values <- which(colnames(after2)%in%a)
#after3 <- after2[,-c(values)]
#CPM3 <- CPM2[,-c(values)]
#after3 <- aftersumlane
#CPM3 <- CPM2

#valuec <- which(rownames(aftersumlanecov)%in%a)
aftercovt <- aftersumlanecov[aftersumlanecov$afterWASPwithXY>10000000,]
#aftercov <- aftercovt[-c(valuec),]
aftercov <- aftercovt

#valueb <- c(grep(a[1], colnames(beforesumlane)), grep(a[2], colnames(beforesumlane)))
#before2 <- beforesumlane
#before2 <- beforesumlane[,-c(valueb)]
#before3 <- before2
#before3 <- before2[,-c(grep(paste(toofewreads, collapse="|"), colnames(before2)))]

b <- colnames(beforesumlane)
#beforecovt <- beforesumlanecov[-c(which(beforesumlanecov$FINDIV%in%a)),]
beforecovt <- beforesumlanecov
beforecov <- beforecovt[which(beforecovt$FC_findiv_lane%in%b),]

CPM_beforesumlane_nowrongsex <- CPM_beforesumlane[,-c(grep(paste(a, collapse="|"), colnames(CPM_beforesumlane)))]
CPM_beforesumlane <- CPM_beforesumlane_nowrongsex
#CPMB1 <- CPMB2[,-c(grep(paste(toofewreads, collapse="|"), colnames(CPMB2)))]

```

```{r removesexgenes, echo=FALSE}
ensGene<-read.table("~/Dropbox/ensGene.txt-2", sep="\t")
ensToName<-read.table("~/Dropbox/ensemblToGeneName.txt", sep="\t")
#table(ensGene$V3)

x.genes<-ensGene[ensGene$V3=="chrX",] # 6001
y.genes<-ensGene[ensGene$V3=="chrY",] # 731
m.genes<-ensGene[ensGene$V3=="chrM",] # 37

# Get the subset in the ensToName sample 
ens.for.x<-intersect(x.genes$V2, ensToName$V1)
ens.for.y<-intersect(y.genes$V2, ensToName$V1)
ens.for.m<-intersect(m.genes$V2, ensToName$V1)

inboth.x<-match(ens.for.x, ensToName$V1)
x.gene.list<-ensToName[inboth.x,]
inboth.y<-match(ens.for.y, ensToName$V1)
y.gene.list<-ensToName[inboth.y,]
inboth.m<-match(ens.for.m, ensToName$V1)
m.gene.list<-ensToName[inboth.m,]

chrX.genes<-unique(x.gene.list$V2)
chrY.genes<-unique(y.gene.list$V2)
chrM.genes<-unique(m.gene.list$V2)

#res.gx <- aftersumlane
x.overlap<-intersect(rownames(aftersumlane), chrX.genes)
y.overlap<-intersect(rownames(aftersumlane), chrY.genes)
m.overlap<-intersect(rownames(aftersumlane), chrM.genes)

inboth.xchr.a <-match(x.overlap, rownames(aftersumlane))
inboth.ychr.a <- match(y.overlap, rownames(aftersumlane))

inboth.xchr.b <-match(x.overlap, rownames(beforesumlane))
inboth.ychr.b <- match(y.overlap, rownames(beforesumlane))

aftersumlane.y.x.all <-aftersumlane[-c(inboth.xchr.a, inboth.ychr.a),]
aftersumlane.y.x <- aftersumlane.y.x.all[rowSums(aftersumlane.y.x.all)>10,]

CPM_aftersumlane.y.x.all <-CPM_aftersumlane[-c(inboth.xchr.a, inboth.ychr.a),]
CPM_aftersumlane.y.x<- CPM_aftersumlane.y.x.all[rowSums(aftersumlane.y.x.all)>10,]

beforesumlane.y.x.all<-beforesumlane[-c(inboth.xchr.b, inboth.ychr.b),]
beforesumlane.y.x <- beforesumlane[rowSums(beforesumlane.y.x.all)>1,]

CPM_beforesumlane.y.x.all<-CPM_beforesumlane[-c(inboth.xchr.b, inboth.ychr.b),]
CPM_beforesumlane.y.x<- CPM_beforesumlane.y.x.all[rowSums(CPM_beforesumlane.y.x.all)>1,]
```

* Total number of chromosome X genes: $`r length(chrX.genes)`$, Y genes: $`r length(chrY.genes)`$, and mt genes: $`r length(chrM.genes)`$

* Number in data that are removed: 
  * X chromosome genes: $`r length(x.overlap)`$
  * Y genes:  $`r length(y.overlap)`$
  * mt genes:  $`r length(m.overlap)`$





#Analysis after combining replicates
##Normalization mean-variance trend looks strange because I didn't remove lowly expressed genes. This is of the expression before combining lanes - but removing those with few reads and who didn't pass sex check.
```{r loadpackages, include=FALSE, cache=FALSE}
#source("http://bioconductor.org/biocLite.R")
#biocLite("edgeR")
#source("https://bioconductor.org/biocLite.R")
#biocLite("sva")

library(limma)
library(edgeR) 
library(sva)
```

```{r normalize, echo=FALSE, fig.height=6, fig.width=10}
#Analysis after combining replicates
###Adding up technical replicates after normalization okay?

voom.after.CPM_aftersumlane.y.x <- voom(CPM_aftersumlane.y.x,plot=TRUE, normalize="quantile")
#looks weird because low counts were not removed.
#voom.after.res <- voom(res.gx.a ,plot=TRUE, normalize="quantile")
voom.matrix.CPM_aftersumlane.y.x<-as.matrix(voom.after.CPM_aftersumlane.y.x)


```
```{r cpmsumlane}
cpm <- cpm(aftersumlane.y.x)
lcpm <- cpm(aftersumlane.y.x, log=TRUE)
table(rowSums(aftersumlane.y.x==0)==441)

keep.exprs <- rowSums(cpm>1)>=10
aftersumlane.y.x.nolowexpressed<- aftersumlane.y.x[keep.exprs, ]
dim(aftersumlane.y.x.nolowexpressed)



dge <- DGEList(counts=aftersumlane.y.x.nolowexpressed)
dge <- calcNormFactors(dge)
logCPM <- cpm(dge, log=TRUE, prior.count=3)
 
x <- DGEList(counts=aftersumlane.y.x.nolowexpressed)
```

```{r notsure, eval=FALSE}
library(RColorBrewer)
nsamples <- ncol(x)
col <- brewer.pal(nsamples, "Paired")
par(mfrow=c(1,2))
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2, 
     main="", xlab="")
title(main="A. Raw data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
 den <- density(lcpm[,i])
 lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")
lcpm <- cpm(x, log=TRUE)
plot(density(lcpm[,1]), col=col[1], lwd=2, ylim=c(0,0.21), las=2, 
     main="", xlab="")
title(main="B. Filtered data", xlab="Log-cpm")
abline(v=0, lty=3)
for (i in 2:nsamples){
   den <- density(lcpm[,i])
   lines(den$x, den$y, col=col[i], lwd=2)
}
legend("topright", samplenames, text.col=col, bty="n")

x <- calcNormFactors(x, method = "TMM")


x2 <- x
x2$samples$norm.factors <- 1
x2$counts[,1] <- ceiling(x2$counts[,1]*0.05)
x2$counts[,2] <- x2$counts[,2]*5

par(mfrow=c(1,2))
lcpm <- cpm(x2, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="A. Example: Unnormalised data",ylab="Log-cpm")
x2 <- calcNormFactors(x2)  
x2$samples$norm.factors

## [1] 0.0547 6.1306 1.2293 1.1705 1.2149 1.0562 1.1459 1.2613 1.1170

lcpm <- cpm(x2, log=TRUE)
boxplot(lcpm, las=2, col=col, main="")
title(main="B. Example: Normalised data",ylab="Log-cpm")


```

##Covariates:
```{r covariates, echo = FALSE}
#Combining covariates - for reads only. 

findivs <- sapply(strsplit(as.character(cov$findiv_lane), "_"), "[", 1)
combinecov <- as.matrix(t(cov[,4:8]))
colnames(combinecov) <- findivs
nms <- colnames(combinecov)
aftercombcov <- as.data.frame(t(combinecov %*% sapply(unique(nms), "==", nms)))
#dim(aftersumlanecov)
#aftercombcov[1:5,c(2,4,5)]


aftercombcov$Findiv <- rownames(aftercombcov)
#head(aftercombcov)

col.order <- colnames(CPM_aftersumlane.y.x.all)
covgood <- read.table("~/Dropbox/covariates.txt", header=T)
covbad<- read.table("~/Dropbox/covariates_badsamples.txt", header = T)

morecov<- rbind(covgood, covbad)
morecov[which(morecov$Findiv=="106581"),"Findiv"]<- "s" 
morecov[which(morecov$Findiv=="106451"),"Findiv"]<- "106581" 
morecov[which(morecov$Findiv=="s"),"Findiv"]<- "106451" 

#remove <- which(morecov$Findiv=="158841")
#morecov <- morecov[-remove,]
#morecov[1:5,1:5]

bothcov <- merge(aftercombcov, morecov, by="Findiv")


#dim(bothcov)
gender <- sapply(bothcov$Findiv, function(x) substr(x, nchar(x), nchar(x)))
new <- bothcov[match(col.order, bothcov$Findiv),]
aftercombcov <-  new
flowlane <- paste(cov$Flowcell, cov$Lane, sep=".")
ff<- cbind(findivs, flowlane)
aggff <- aggregate(flowlane ~ findivs, data=ff, FUN=paste, collapse=",")
afindiv <- colnames(CPM_aftersumlane.y.x.all)
new2 <- aggff[which(aggff$findivs%in%afindiv),]
new3 <- new2[match(col.order, new2$findivs),]
uflowcells <- unique(new3$flowlane)
aa <- as.data.frame(cbind(uflowcells, c(1:98)))
colnames(aa) <- c("flowlane", "code")
a2 <- merge(new3, aa, by="flowlane")
newa <- a2[match(col.order, a2$findivs),]

aftercombcov$flowlane <- newa$code

cov2<- aftercombcov

gender <- sapply(cov2$Findiv, function(x) substr(x, nchar(x), nchar(x)))

indiv<-as.factor(cov2$Findiv)
sex<-as.factor(gender)
#can't check lane after combining across lanes
#lane <- as.factor(bothcov$Lane)
#index <- as.factor(cov$Index)
#can't check lane after combining across lanes
#Flowcell <- as.factor(cov$Flowcell)
#readsbeforeW <- as.numeric(cov2$beforeWASP)
readsafterWsex <- as.numeric(cov2$afterWASPwithXY)
#readsafterW <- as.numeric(cov2$afterWASP)
rnaconc <- as.numeric(cov2$RNAConc)
rin <- as.numeric(cov2$RIN)
batch <- as.factor(cov2$LibPrepBatch)
prep <- as.factor(cov2$LibraryPrepBy)
conc <- as.numeric(cov2$LibraryConc)
length <- as.numeric(cov2$FragmentLength)
flowlane <- as.factor(cov2$flowlane)
index <- as.factor(cov2$Index)

gx.covars<-data.frame(cbind( sex,  readsafterWsex,  rnaconc, rin, batch, prep, conc, length, flowlane, index))
head(gx.covars)

```


* RIN, Batch and RNA concentration were significant, so plot by first two PC's:

```{r pccombine_aftercombat, eval=FALSE, echo = FALSE}

plot(sum.PC$x[,1], sum.PC$x[,2],
     pch=20,main=paste(title.PC, " colored by RIN"),
     xlab=paste("PC 1 -", (sumsum$importance[2,1]*100),"% of variance", sep=" "), 
     ylab=paste("PC 2 -",(sumsum$importance[2,2]*100),"% of variance", sep=" "),
     col=rin) 

plot(sum.PC$x[,1], sum.PC$x[,2],
     pch=20,main=paste(title.PC, " colored by Batch"),
     xlab=paste("PC 1 -", (sumsum$importance[2,1]*100),"% of variance", sep=" "), 
     ylab=paste("PC 2 -",(sumsum$importance[2,2]*100),"% of variance", sep=" "),
     col=batch)

plot(sum.PC$x[,1], sum.PC$x[,2],
     pch=20,main=paste(title.PC, " colored by RNA concentration"),
     xlab=paste("PC 1 -", (sumsum$importance[2,1]*100),"% of variance", sep=" "), 
     ylab=paste("PC 2 -",(sumsum$importance[2,2]*100),"% of variance", sep=" "),
     col=rnaconc)

#write.table(pval.pca1, "50PCs_vs_covar_preAdj_TMMgx_41216.txt", sep="\t", quote=FALSE)
```

### TMM Normalization

```{r sva_regress_out_Flowcell, echo = FALSE}

my_DGEList = DGEList(counts=aftersumlane.y.x.nolowexpressed)
my_DGEList_TMM = calcNormFactors(my_DGEList, method="TMM")
my_data = cpm(my_DGEList_TMM, log=TRUE)
#my_data = cpm(my_DGEList_TMM, log=TRUE, prior.count=1)
#my_mod = model.matrix(~as.numeric(rin), data=gx.covars) #Use this only if you're going to protect something
#batch= (gx.covars$batch)
#modcombat = model.matrix(~1, data=gx.covars)
#combat_batch = ComBat(my_data, batch=batch, mod=my_mod,  par.prior=TRUE, prior.plots=FALSE)
```

##PCA:
* First PCA showing variation of Proportion of Variance in PCs and correlation with covariates:

```{r pccombine_aftercombat1, echo = FALSE}
pc_list=c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PC16", "PC17", "PC18", "PC19", "PC20", "PC21", "PC22", "PC23", "PC24", "PC25", "PC26", "PC27", "PC28", "PC29", "PC30", "PC31", "PC32", "PC33", "PC34", "PC35", "PC36", "PC37", "PC38", "PC39", "PC40", "PC41", "PC42", "PC43", "PC44", "PC45", "PC46", "PC47", "PC48", "PC49", "PC50")


# Calculate PCs: 
sum.PC <- prcomp(t(my_data), scale=FALSE, center=TRUE)
sumsum <- summary(sum.PC)
prop.var<-sumsum$importance
prop.var[1:3,1:20] 
title.PC<-"PCA "

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca1=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca1)=pc_list
colnames(pval.pca1)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data1= lm(sum.PC$x[,i]~gx.covars[,j])
    pval.pca1[i,j]=anova(data1)$'Pr(>F)'[1]
  }
}

head(pval.pca1)
```

### Regress out RIN

* PCA for the second time:

```{r regress_out_rin, echo = FALSE}
r.residual.int = matrix(nrow= nrow(my_data), ncol = ncol(my_data))
rownames(r.residual.int) = rownames(my_data)
colnames(r.residual.int) = colnames(my_data)
for (i in 1:nrow(my_data)) {
  model.i= lm(my_data[i,]~ gx.covars[,4])
  r.residual.int[i,] = resid(model.i) + model.i$coefficients[1]
}

sum.PC <- prcomp(t(r.residual.int), scale=FALSE, center=TRUE)
sumsum <- summary(sum.PC)
prop.var<-sumsum$importance
prop.var[1:3,1:20] 
title.PC<-"PCA 2"

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca1=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca1)=pc_list
colnames(pval.pca1)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data2= lm(sum.PC$x[,i]~gx.covars[,j])
    pval.pca1[i,j]=anova(data2)$'Pr(>F)'[1]
  }
}

head(pval.pca1)

#plot( gx.covars$batch, sum.PC$x[,1], main="Batch by PC1")
#plot( gx.covars$batch, sum.PC$x[,5], main="Batch by PC5")

```

* RNA concentration correlated with PC1, regress that out:

### Regress out RNA concentration

```{r regress_out_rnaconcentration, echo = FALSE}
r.residual.int2 = matrix(nrow= nrow(r.residual.int), ncol = ncol(r.residual.int))
rownames(r.residual.int2) = rownames(r.residual.int)
colnames(r.residual.int2) = colnames(r.residual.int)
for (i in 1:nrow(r.residual.int)) {
  model.i= lm(r.residual.int[i,]~ gx.covars[,3])
  r.residual.int2[i,] = resid(model.i) + model.i$coefficients[1]
}

sum.PC <- prcomp(t(r.residual.int2), scale=FALSE, center=TRUE)
sumsum <- summary(sum.PC)
prop.var<-sumsum$importance
prop.var[1:3,1:20] 
title.PC<-"PCA 3 "

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca1=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca1)=pc_list
colnames(pval.pca1)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data1= lm(sum.PC$x[,i]~gx.covars[,j])
    pval.pca1[i,j]=anova(data1)$'Pr(>F)'[1]
  }
}

head(pval.pca1)

```


* Flowcell/lane next correlated covariate with PC3

##Using ComBat to regress out Flowcell/lane

```{r pcacheck_after_batch, echo = FALSE, eval=FALSE}
#source("https://bioconductor.org/biocLite.R")
#biocLite("sva")
library(sva)
my_mod = model.matrix(~1, data=gx.covars) #Use this only if you're going to protect something
batch= (gx.covars$batch)
#modcombat = model.matrix(~1, data=gx.covars)
combat_batch = ComBat(r.residual.int2, batch=batch, mod=my_mod,  par.prior=TRUE, prior.plots=FALSE)


newdata<- combat_batch
sum.PC2 <- prcomp(t(newdata), scale=TRUE, center=FALSE, na.action=na.omit)
sumsum2 <- summary(sum.PC2)
prop.var2<-sumsum2$importance
prop.var2[1:3,1:20] 
title.PC<-"PCA 4"

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca2=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca2)=pc_list
colnames(pval.pca2)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data2= lm(sum.PC2$x[,i]~gx.covars[,j])
    pval.pca2[i,j]=anova(data2)$'Pr(>F)'[1]
  }
}
head(pval.pca2)

```


* Batch next correlated covariate

###Using combat to regress out batch

```{r, correcting_batch, echo = FALSE, eval=FALSE}

my_mod = model.matrix(~1, data=gx.covars) #Use this only if you're going to protect something
batch= (gx.covars$flowlane)
#modcombat = model.matrix(~1, data=gx.covars)
combat_batch = ComBat(newdata, batch=batch, mod=my_mod,  par.prior=TRUE, prior.plots=FALSE)


newdata2<- combat_batch
sum.PC2 <- prcomp(t(newdata2), scale=TRUE, center=FALSE, na.action=na.omit)
sumsum2 <- summary(sum.PC2)
prop.var2<-sumsum2$importance
prop.var2[1:3,1:20] 
title.PC<-"PCA 4"

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca2=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca2)=pc_list
colnames(pval.pca2)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data2= lm(sum.PC2$x[,i]~gx.covars[,j])
    pval.pca2[i,j]=anova(data2)$'Pr(>F)'[1]
  }
}
head(pval.pca2)
```

* When Flowcell/Lane is regressed out, it seems that the covariate batch becomes signficantly correlated with PC3 and moreso than Flowcell/Lane was before it was regressed out. 


# 05-18-16 decided to only do TMM normalization but not regress out effects: 
# So use my_data moving forward for now.

```{r maternal and paternal, echo =FALSE, eval=FALSE}
#5-18-16 decided to only do TMM normalization but not regress out effects: 
# SO use my_data moving forward for now.
my_data <- r.residual.int2
maternal<- read.table("~/star_overhang_v19_genecount_genes_maternal", check.names = FALSE)
paternal<- read.table("~/star_overhang_v19_genecount_genes_paternal", check.names = FALSE)

mat <- as.matrix(maternal)
findivs <- sapply(strsplit(colnames(mat), "_"), "[", 2)
colnames(mat) <- findivs
nms <- colnames(mat)
aftersumlanemat <- mat %*% sapply(unique(nms), "==", nms)

pat <- as.matrix(paternal)
findivs <- sapply(strsplit(colnames(pat), "_"), "[", 2)
colnames(pat) <- findivs
nms <- colnames(pat)
aftersumlanepat <- pat %*% sapply(unique(nms), "==", nms)
findivs<- colnames(aftersumlanepat)

#No parent of origin information for:
colnames(my_data)[which(!colnames(my_data)%in%findivs)]
missing <- which(!colnames(my_data)%in%findivs)

#Removed from qc:
findivs[which(!findivs%in%colnames(my_data))]
removed <- which(!findivs%in%colnames(my_data))

newer <- my_data[,-c(missing)]
genes<- rownames(newer)
newmat <- aftersumlanemat[genes,-c(removed)]
newpat <- aftersumlanepat[genes,-c(removed)]


aftersumlaneprop <- aftersumlane[genes,colnames(newer)]

str(newmat)
dim(newmat)
str(aftersumlaneprop)
dim(aftersumlaneprop)

propmat <- newmat/aftersumlaneprop
proppat <- newpat/aftersumlaneprop

newermat2 <- propmat*newer
newerpat2 <- proppat*newer

newermat2[is.na(newermat2)] <- 0
newerpat2[is.na(newerpat2)] <- 0

write.table(newerpat2, "Paternal_gene_normalized_v19log.txt", quote =F, row.names = T, col.names = T)
write.table(newermat2, "Maternal_gene_normalized_v19log.txt", quote =F, row.names = T, col.names = T)


g <- c()
for (i in 1:dim(newermat2)[1]) {
    for (j in 1:dim(newermat2)[2]) {
      if (newermat2[i,j] > newerpat2[i,j]) {
        if (j == dim(newermat2)[2]) {
            g <- c(g, i)
        }
      } else {
        break
      }
    }
}

```

```{r unknown, echo = FALSE, eval=FALSE}

keep <- read.table("~/star_overhang_v19_genecount_genes_hom", check.names = F)
k <- as.matrix(keep)
findivs <- sapply(strsplit(colnames(k), "_"), "[", 2)
colnames(k) <- findivs
nms <- colnames(k)
aftersumlanekeep <- k %*% sapply(unique(nms), "==", nms)
findivs<- colnames(aftersumlanekeep)

pofindivs <- colnames(newerpat2)
newkeep <- aftersumlanekeep[genes,which(findivs%in%pofindivs)]

propkeep <- newkeep/aftersumlaneprop

newerkeep <- propkeep*newer
newerkeep[is.na(newerkeep)] <- 0

write.table(newerkeep, "Unknown_gene_normalized_v19log.txt", quote =F, row.names = T, col.names = T)
write.table(newer, "Total_gene_normalized_v19log.txt", quote = F, row.names = T, col.names = T)

```



```{r imprinted, echo = FALSE, eval=FALSE}


#Imprinted Genes

imprinted <- read.table("~/Imprintedgenenames.txt")
genes<- rownames(mat)
a <- c()
imgenes<- c()
for (i in 1:dim(imprinted)[1]) {
    a <- c(a, grep(imprinted[i,1], genes))
    imgenes <- c(imgenes, i)
}
length(imgenes)

matim <- c()
patim <- c()
for(j in 1:dim(mat)[1]) {
    if (sum(mat[j,]) < 1) {
       if (sum(pat[j,]) > 5) {
          matim <- c(matim, j)
        }
    }
}
for(j in 1:dim(pat)[1]) {
    if (sum(pat[j,]) < 1) {
       if (sum(mat[j,]) > 5) {
          patim <- c(patim, j)
        }
    }
}



equal <- c()
for(j in 1:dim(mat)[1]) {
    if (sum(mat[j,]) >20) {
        if (sum(mat[j,]) == sum(pat[j,])) {
          equal <- c(equal, j)
        }
    }
}


```

