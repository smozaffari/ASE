---
title: "LCL"
author: "Sahar Mozaffari"
date: "5/22/2017"
output:
  pdf_document: default
  html_document: default
---

R Markdown for RNA-seq data

##Genecount matrix:
* genes in rows, individuals/samples by lane and flowcell in columns

```{r Genecountmatrix, echo=FALSE}
library(plyr)
library(dplyr)
library(reshape2)
run1 <- read.table("~/star_overhang_v19_genecount_withsexReadsPerGene.out.tab", check.names = F)
maternalrun1  <- read.table("~/star_overhang_v19_genecount_maternalaltcountReadsPerGene.out.tab", check.names=F)
paternalrun1  <- read.table("~/star_overhang_v19_genecount_paternalaltcountReadsPerGene.out.tab", check.names=F)
homrun1  <- read.table("~/star_overhang_v19_genecount_homaltcountReadsPerGene.out.tab", check.names=F)
genesrun1  <- read.table("~/star_overhang_v19_genecount_genesaltcountReadsPerGene.out.tab", check.names=F)
```
* There are a total of $`r dim(count)[1]-5`$ genes and $`r dim(count)[2]`$ samples

##Covariates
* covariate file has number of reads from total, maternal, and paternal; flowcell, findiv, lane, and adaptor index

```{r sampleswaps, echo = FALSE}
run1names <- colsplit(string=colnames(homrun1), pattern="_", names=c("FC", "findiv", "lanetext","lane", "remainder"))
colnames(run1) <- paste(run1names$FC, run1names$findiv, run1names$lanetext,  run1names$lane, sep="_")
colnames(paternalrun1) <- paste(run1names$FC, run1names$findiv, run1names$lanetext, run1names$lane, sep="_")
colnames(maternalrun1) <- paste(run1names$FC, run1names$findiv, run1names$lanetext, run1names$lane, sep="_")
colnames(homrun1) <- paste(run1names$FC, run1names$findiv, run1names$lanetext, run1names$lane, sep="_")
colnames(genesrun1) <- paste(run1names$FC, run1names$findiv, run1names$lanetext, run1names$lane, sep="_")

count <- run1
colnames(count)[which(colnames(count)=="9_106451_lane_4")] <- "9_106581_lane_4"
colnames(count)[which(colnames(count)=="9_106451_lane_5")] <- "9_106581_lane_5"

colnames(count)[which(colnames(count)=="5_106581_lane_3")] <- "5_106451_lane_3"
colnames(count)[which(colnames(count)=="5_106581_lane_4")] <- "5_106451_lane_4"

colnames(count)[which(colnames(count)=="7_160591_lane_7")] <- "7_106972_lane_7"
colnames(count)[which(colnames(count)=="7_160591_lane_8")] <- "7_106972_lane_8"

colnames(count)[which(colnames(count)=="7_106952_lane_7")]  <- "7_160591_lane_7"
colnames(count)[which(colnames(count)=="7_106952_lane_8")]  <- "7_160591_lane_8"

colnames(count)[which(colnames(count)=="7_158841_lane_5")]  <- "7_158471_lane_5"
colnames(count)[which(colnames(count)=="7_158841_lane_6")]  <- "7_158471_lane_6"


count[,which(colnames(count)=="11_108211_lane_3")]  <- NULL
count[,which(colnames(count)=="11_108211_lane_4")]  <- NULL
count[,which(colnames(count)=="9_108211_lane_4")]  <- NULL
count[,which(colnames(count)=="9_108211_lane_5")]  <- NULL

count[,which(colnames(count)=="4_160462_lane_1")]  <- NULL
count[,which(colnames(count)=="4_160462_lane_2")]  <- NULL

count[,which(colnames(count)=="3_173492_lane_1")]  <- NULL
count[,which(colnames(count)=="3_173492_lane_2")]  <- NULL

count[,which(colnames(count)=="11_110432_lane_3")]  <- NULL
count[,which(colnames(count)=="11_110432_lane_4")]  <- NULL


```



```{r lane, echo=FALSE}
#File that has flowcell, lane & adaptor index
laneindex <- read.table("~/li_6_v19")
colnames(laneindex) <- c("Flowcell", "FINDIV", "Lane", "Adaptor_index")

```

```{r sampleswaps2, echo = FALSE}

laneindex[which(laneindex$Flowcell==5 & laneindex$FINDIV==106581 & laneindex$Lane==3),"FINDIV"] <- 106451
laneindex[which(laneindex$Flowcell==5 & laneindex$FINDIV==106581 & laneindex$Lane==4),"FINDIV"] <- 106451

laneindex[which(laneindex$Flowcell==9 & laneindex$FINDIV==106451 & laneindex$Lane==4),"FINDIV"] <- 106581
laneindex[which(laneindex$Flowcell==9 & laneindex$FINDIV==106451 & laneindex$Lane==5),"FINDIV"] <- 106581

laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==160591 & laneindex$Lane==7),"FINDIV"] <- 106972
laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==160591 & laneindex$Lane==8),"FINDIV"] <- 106972

laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==106952 & laneindex$Lane==7),"FINDIV"] <- 160591
laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==106952 & laneindex$Lane==8),"FINDIV"] <- 160591

laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==158841 & laneindex$Lane==5),"FINDIV"] <- 158471
laneindex[which(laneindex$Flowcell==7 & laneindex$FINDIV==158841 & laneindex$Lane==6),"FINDIV"] <- 158471

remove <- c(which(laneindex$Flowcell==11 & laneindex$FINDIV==108211 & laneindex$Lane==3),
            which(laneindex$Flowcell==11 & laneindex$FINDIV==108211 & laneindex$Lane==4),
            which(laneindex$Flowcell==9 & laneindex$FINDIV==108211 & laneindex$Lane==4),
            which(laneindex$Flowcell==9 & laneindex$FINDIV==108211 & laneindex$Lane==5),
            which(laneindex$Flowcell==4 & laneindex$FINDIV==160462 & laneindex$Lane==1),
            which(laneindex$Flowcell==4 & laneindex$FINDIV==160462 & laneindex$Lane==2),
            which(laneindex$Flowcell==3 & laneindex$FINDIV==173492 & laneindex$Lane==1),
            which(laneindex$Flowcell==3 & laneindex$FINDIV==173492 & laneindex$Lane==2),
            which(laneindex$Flowcell==11 & laneindex$FINDIV==110432 & laneindex$Lane==3),
            which(laneindex$Flowcell==11 & laneindex$FINDIV==110432 & laneindex$Lane==4))

laneindex <- laneindex[-remove,]
run1 <- count

```





##Number of lanes with enough reads, before combining replicates
```{r reads, echo=FALSE, fig.height=3, fig.width=10}
star.output <-run1[1:4,]
resrun1 <- run1[-c(1:4),]
CS=colSums(resrun1)
barplot(sort(CS), ylim=c(0, 40000000), main="Total mapped read counts")
abline(h=5000000, col="red")
text(50,1e07, "5,000,000", col="red")
```

* The distribution of Counts Per Million:

```{r CPM, echo=FALSE, fig.height=5, fig.width=10}
counts1 = resrun1+1
CPM_beforesumlane = apply(counts1, 2, function(x) (x*1000000)/sum(x))
hist(log2(CPM_beforesumlane), main = "CPM")

```

##Sexcheck
###Sex assigned by ratio of XIST to EIF1AY gene

```{r sex, echo=FALSE, fig.height=3, fig.width=10}
#XIST: ENSG00000229807 
#EIF1AY: ENSG00000198692
sexRatio = log2(resrun1["ENSG00000229807",]+1) - log2(resrun1["ENSG00000198692",]+1)
# if this is > 0, Female, < 0, male based on expression
callSex= ifelse(sexRatio >0, "F", "M")
table(callSex)
```

* According to expression of sex genes, there are $`r length(which(callSex=="F"))`$ females and $`r length(which(callSex=="M"))`$ males.


```{r gender, echo=FALSE}
###Actual gender, 1 = Male, 2 = Female
findivs <- sapply(strsplit(colnames(resrun1), "_"), "[", 2)
names(sexRatio) <- findivs
gender <- sapply(findivs, function(x) substr(x, nchar(x), nchar(x)))
table(gender)
plot( as.factor(gender), unlist(sexRatio), ylab = "log2(XIST)- log2(EIF1AY)", main = "Expression of gender assigning genes, vs gender")
#colnames(callSex) <- names(gender)


```
* There are supposed to be: $`r length(which(callSex=="2"))`$ females and $`r length(which(callSex=="1"))`$ males.
* The samples misassigned are: $`r sexRatio[which((callSex=="F")&gender==1)]`$ 

#Combining technical replicates
* gene count matrix combined across lanes/flowcells so that each individual has one sum value of gene expression for each gene

```{r combinelanes1, echo=FALSE}
 #Combining gene count matrix
beforesumlane <- resrun1
res.matrix<- as.matrix(resrun1)
findivs <- sapply(strsplit(colnames(res.matrix), "_"), "[", 2)
colnames(res.matrix) <- findivs
nms <- colnames(res.matrix)
aftersumlane_mismatch <- res.matrix %*% sapply(unique(nms), "==", nms)
aftersumlane<- aftersumlane_mismatch[,order(colnames(aftersumlane_mismatch))]
aftersumlane[1:5,1:5]

CS=colSums(aftersumlane)
barplot(sort(CS), ylim=c(0, 100000000), main="Total mapped read counts")
abline(h=6000000, col="red")
abline(h=10000000, col="green")
text(50,2e07, "6,000,000", col="red")
text(50,5e07, "10,000,000", col="green")
```

* combine total number of read covariate value

```{r toofewreads, echo=FALSE, fig.height=5, fig.width=10}
toofewreads <- names(CS[which(CS<10000000)])
```


*  After combining replicates, $`r toofewreads`$ out of total $`r length(CS)`$ have more than 10 million reads
* The distribution of Counts Per Million after combining replicates:

```{r CPMaftercombine, echo=FALSE, fig.height=5, fig.width=10}
counts1 = aftersumlane+1
CPM_aftersumlane = apply(counts1, 2, function(x) (x*1000000)/sum(x))
hist(log2(CPM_aftersumlane), main = "CPM")
```

##Checking sex after combining replicates

```{r genderaftercombine, echo=FALSE}

#XIST: ENSG00000229807 
#EIF1AY: ENSG00000198692
head(aftersumlane["ENSG00000229807.5",1:5])
sexRatio = log2(aftersumlane["ENSG00000229807.5",]+1) - log2(aftersumlane["ENSG00000198692.5",]+1)
# if this is > 0, Female, < 0, male based on expression
callSex= ifelse(sexRatio >0, "F", "M")
table(callSex)

findivs <- colnames(aftersumlane)
names(sexRatio) <- findivs
gender <- sapply(findivs, function(x) substr(x, nchar(x), nchar(x)))
table(gender)
plot(as.factor(gender), sexRatio, ylab = "log2(XIST)- log2(EIF1AY)", main = "Expression of gender assigning genes, vs gender")
wrongsex <- sexRatio[c(which((callSex=="F") &gender==1), which((callSex=="M")&gender==2))]
wrongsex
a <- names(wrongsex[abs(wrongsex)>1])
a
largesex<- which(abs(wrongsex)>5)
largesex
```

* There are supposed to be: $`r length(which(callSex=="F"))`$ females and $`r length(which(callSex=="M"))`$ males.
* The samples misassigned are: $`r names(sexRatio[which((callSex=="F")&gender==1)])`$ 


###These $`r length(wrongsex)`$ individuals have wrong assigned sex- last $`r length(largesex)`$ have quite a large error - remove `r a` from data

#Removing X and Y chromosome (and mitochondrial) genes --(and genes not expressed in anyone)--

```{r removesexgenes, echo=FALSE}
ensGene<-read.table("~/Dropbox/ensGene.txt-2", sep="\t")
ensToName<-read.table("~/Dropbox/ensemblToGeneName.txt", sep="\t")
#table(ensGene$V3)

x.genes<-ensGene[ensGene$V3=="chrX",13] # 6001
y.genes<-ensGene[ensGene$V3=="chrY",13] # 731
m.genes<-ensGene[ensGene$V3=="chrM",13] # 37

# Get the subset in the ensToName sample 
#ens.for.x<-intersect(x.genes$V2, ensToName$V1)
#ens.for.y<-intersect(y.genes$V2, ensToName$V1)
#ens.for.m<-intersect(m.genes$V2, ensToName$V1)

#inboth.x<-match(ens.for.x, ensToName$V1)
#x.gene.list<-ensToName[inboth.x,]
#inboth.y<-match(ens.for.y, ensToName$V1)
#y.gene.list<-ensToName[inboth.y,]
#inboth.m<-match(ens.for.m, ensToName$V1)
#m.gene.list<-ensToName[inboth.m,]

chrX.genes<-unique(x.genes)
chrY.genes<-unique(y.genes)
chrM.genes<-unique(m.genes)

#res.gx <- aftersumlane
aftersumgenes <- gsub("\\..*","",rownames(aftersumlane))
rownames(aftersumlane)<- aftersumgenes
x.overlap<-intersect(aftersumgenes, chrX.genes)
y.overlap<-intersect(aftersumgenes, chrY.genes)
m.overlap<-intersect(aftersumgenes, chrM.genes)

inboth.xchr.a <-match(x.overlap, rownames(aftersumlane))
inboth.ychr.a <- match(y.overlap, rownames(aftersumlane))

inboth.xchr.b <-match(x.overlap, rownames(beforesumlane))
inboth.ychr.b <- match(y.overlap, rownames(beforesumlane))

aftersumlane.y.x.all <-aftersumlane[-c(inboth.xchr.a, inboth.ychr.a),]
aftersumlane.y.x <- aftersumlane.y.x.all[rowSums(aftersumlane.y.x.all)>10,]

CPM_aftersumlane.y.x.all <-CPM_aftersumlane[-c(inboth.xchr.a, inboth.ychr.a),]
CPM_aftersumlane.y.x<- CPM_aftersumlane.y.x.all[rowSums(aftersumlane.y.x.all)>10,]

beforesumlane.y.x.all<-beforesumlane[-c(inboth.xchr.b, inboth.ychr.b),]
beforesumlane.y.x <- beforesumlane[rowSums(beforesumlane.y.x.all)>1,]

CPM_beforesumlane.y.x.all<-CPM_beforesumlane[-c(inboth.xchr.b, inboth.ychr.b),]
CPM_beforesumlane.y.x<- CPM_beforesumlane.y.x.all[rowSums(CPM_beforesumlane.y.x.all)>1,]
```

* Total number of chromosome X genes: $`r length(chrX.genes)`$, Y genes: $`r length(chrY.genes)`$, and mt genes: $`r length(chrM.genes)`$

* Number in data that are removed: 
  * X chromosome genes: $`r length(x.overlap)`$
  * Y genes:  $`r length(y.overlap)`$
  * mt genes:  $`r length(m.overlap)`$





#Analysis after combining replicates
##Normalization mean-variance trend looks strange because I didn't remove lowly expressed genes. This is of the expression before combining lanes - but removing those with few reads and who didn't pass sex check.
```{r loadpackages, include=FALSE, cache=FALSE}
#source("http://bioconductor.org/biocLite.R")
#biocLite("edgeR")
#source("https://bioconductor.org/biocLite.R")
#biocLite("sva")

library(limma)
library(edgeR) 
library(sva)
```

```{r normalize, echo=FALSE, fig.height=6, fig.width=10}
#Analysis after combining replicates
###Adding up technical replicates after normalization okay?

voom.after.CPM_aftersumlane.y.x <- voom(CPM_aftersumlane.y.x,plot=TRUE, normalize="quantile")
#looks weird because low counts were not removed.
#voom.after.res <- voom(res.gx.a ,plot=TRUE, normalize="quantile")
voom.matrix.CPM_aftersumlane.y.x<-as.matrix(voom.after.CPM_aftersumlane.y.x)


```

```{r cpmsumlane}
cpm <- cpm(aftersumlane.y.x)
lcpm <- cpm(aftersumlane.y.x, log=TRUE)
table(rowSums(aftersumlane.y.x==0)==438)

keep.exprs <- rowSums(cpm>1)>=10
aftersumlane.y.x.nolowexpressed<- aftersumlane.y.x[keep.exprs, ]
dim(aftersumlane.y.x.nolowexpressed)



dge <- DGEList(counts=aftersumlane.y.x.nolowexpressed)
dge <- calcNormFactors(dge)
logCPM <- cpm(dge, log=TRUE, prior.count=3)
 
x <- DGEList(counts=aftersumlane.y.x.nolowexpressed)
```

##Covariates:
```{r covariates, echo = FALSE}
#Combining covariates - for reads only. 
#cov <- run1names
#findivs <- run1names$findiv
#combinecov <- as.matrix(t(cov[,4:8]))
#colnames(combinecov) <- findivs
#nms <- colnames(combinecov)
#aftercombcov <- as.data.frame(t(combinecov %*% sapply(unique(nms), "==", nms)))
#dim(aftersumlanecov)
#aftercombcov[1:5,c(2,4,5)]


#aftercombcov$Findiv <- rownames(aftercombcov)
#head(aftercombcov)

col.order <- colnames(CPM_aftersumlane.y.x.all)
covgood <- read.table("~/Dropbox/covariates.txt", header=T)
covbad<- read.table("~/Dropbox/covariates_badsamples.txt", header = T)

morecov<- rbind(covgood, covbad)
morecov[which(morecov$Findiv=="106581"),"Findiv"]<- "s" 
morecov[which(morecov$Findiv=="106451"),"Findiv"]<- "106581" 
morecov[which(morecov$Findiv=="s"),"Findiv"]<- "106451" 
morecov[which(morecov$Findiv=="160591"),"Findiv"]<- "106972" 
morecov[which(morecov$Findiv=="106952"),"Findiv"]<- "160591" 
morecov[which(morecov$Findiv=="158841"),"Findiv"]<- "158471" 

toremove <- c(which(morecov$Findiv=="108211"), which(morecov$Findiv=="160462"), which(morecov$Findiv=="173492"), which(morecov$Findiv=="110432") )

morecov <- morecov[-c(toremove),]

run1names[which(run1names$findiv=="106581"),"findiv"]<- "s" 
run1names[which(run1names$findiv=="106451"),"findiv"]<- "106581" 
run1names[which(run1names$findiv=="s"),"findiv"]<- "106451" 
run1names[which(run1names$findiv=="160591"),"findiv"]<- "106972"  
run1names[which(run1names$findiv=="106952"),"findiv"]<- "160591" 
run1names[which(run1names$findiv=="158841"),"findiv"]<- "158471" 

toremovename <- c(which(run1names$findiv=="108211"), which(run1names$findiv=="160462"), which(run1names$findiv=="173492"), which(run1names$findiv=="110432") )
run1names1 <- run1names[-c(toremovename),]

#remove <- which(morecov$Findiv=="158841")
#morecov <- morecov[-remove,]
#morecov[1:5,1:5]

#bothcov <- merge(aftercombcov, morecov, by="Findiv")
bothcov <-morecov
cov <- run1names1 
#dim(bothcov)
gender <- sapply(bothcov$Findiv, function(x) substr(x, nchar(x), nchar(x)))
new <- bothcov[match(col.order, bothcov$Findiv),]
aftercombcov <-  new
flowlane <- paste(cov$FC, cov$lane, sep=".")
ff<- cbind(findivs, flowlane)
aggff <- aggregate(flowlane ~ findivs, data=ff, FUN=paste, collapse=",")
afindiv <- colnames(CPM_aftersumlane.y.x.all)
new2 <- aggff[which(aggff$findivs%in%afindiv),]
new3 <- new2[match(col.order, new2$findivs),]
uflowcells <- unique(new3$flowlane)
aa <- as.data.frame(cbind(uflowcells, c(1:98)))
colnames(aa) <- c("flowlane", "code")
a2 <- merge(new3, aa, by="flowlane")
newa <- a2[match(col.order, a2$findivs),]

aftercombcov$flowlane <- newa$code

cov2<- aftercombcov

gender <- sapply(cov2$Findiv, function(x) substr(x, nchar(x), nchar(x)))

indiv<-as.factor(cov2$Findiv)
sex<-as.factor(gender)
#can't check lane after combining across lanes
#lane <- as.factor(bothcov$Lane)
#index <- as.factor(cov$Index)
#can't check lane after combining across lanes
#Flowcell <- as.factor(cov$Flowcell)
#readsbeforeW <- as.numeric(cov2$beforeWASP)
#readsafterWsex <- as.numeric(cov2$TotalReads)
#readsafterW <- as.numeric(cov2$afterWASP)
rnaconc <- as.numeric(cov2$RNAConc)
rin <- as.numeric(cov2$RIN)
batch <- as.factor(cov2$LibPrepBatch)
prep <- as.factor(cov2$LibraryPrepBy)
conc <- as.numeric(cov2$LibraryConc)
length <- as.numeric(cov2$FragmentLength)
flowlane <- as.factor(cov2$flowlane)
index <- as.factor(cov2$Index)

gx.covars<-data.frame(cbind( sex, indiv, rnaconc, rin, batch, prep, conc, length, flowlane, index))
head(gx.covars)

```


* RIN, Batch and RNA concentration were significant, so plot by first two PC's:

```{r pccombine_aftercombat, eval=FALSE, echo = FALSE}

plot(sum.PC$x[,1], sum.PC$x[,2],
     pch=20,main=paste(title.PC, " colored by RIN"),
     xlab=paste("PC 1 -", (sumsum$importance[2,1]*100),"% of variance", sep=" "), 
     ylab=paste("PC 2 -",(sumsum$importance[2,2]*100),"% of variance", sep=" "),
     col=rin) 

plot(sum.PC$x[,1], sum.PC$x[,2],
     pch=20,main=paste(title.PC, " colored by Batch"),
     xlab=paste("PC 1 -", (sumsum$importance[2,1]*100),"% of variance", sep=" "), 
     ylab=paste("PC 2 -",(sumsum$importance[2,2]*100),"% of variance", sep=" "),
     col=batch)

plot(sum.PC$x[,1], sum.PC$x[,2],
     pch=20,main=paste(title.PC, " colored by RNA concentration"),
     xlab=paste("PC 1 -", (sumsum$importance[2,1]*100),"% of variance", sep=" "), 
     ylab=paste("PC 2 -",(sumsum$importance[2,2]*100),"% of variance", sep=" "),
     col=rnaconc)

#write.table(pval.pca1, "50PCs_vs_covar_preAdj_TMMgx_41216.txt", sep="\t", quote=FALSE)
```

### TMM Normalization

```{r sva_regress_out_Flowcell, echo = FALSE}


my_DGEList = DGEList(counts=aftersumlane.y.x.nolowexpressed)
my_DGEList_TMM = calcNormFactors(my_DGEList, method="TMM")
my_data = cpm(my_DGEList_TMM, log=TRUE)
#my_data = cpm(my_DGEList_TMM, log=TRUE, prior.count=1)
#my_mod = model.matrix(~as.numeric(rin), data=gx.covars) #Use this only if you're going to protect something
#batch= (gx.covars$batch)
#modcombat = model.matrix(~1, data=gx.covars)
#combat_batch = ComBat(my_data, batch=batch, mod=my_mod,  par.prior=TRUE, prior.plots=FALSE)
```

##PCA:
* First PCA showing variation of Proportion of Variance in PCs and correlation with covariates:

```{r pccombine_aftercombat1, echo = FALSE}
pc_list=c("PC1", "PC2", "PC3", "PC4", "PC5", "PC6", "PC7", "PC8", "PC9", "PC10", "PC11", "PC12", "PC13", "PC14", "PC15", "PC16", "PC17", "PC18", "PC19", "PC20", "PC21", "PC22", "PC23", "PC24", "PC25", "PC26", "PC27", "PC28", "PC29", "PC30", "PC31", "PC32", "PC33", "PC34", "PC35", "PC36", "PC37", "PC38", "PC39", "PC40", "PC41", "PC42", "PC43", "PC44", "PC45", "PC46", "PC47", "PC48", "PC49", "PC50")


# Calculate PCs: 
sum.PC <- prcomp(t(my_data), scale=FALSE, center=TRUE)
sumsum <- summary(sum.PC)
prop.var<-sumsum$importance
prop.var[1:3,1:20] 
title.PC<-"PCA "

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca1=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca1)=pc_list
colnames(pval.pca1)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data1= lm(sum.PC$x[,i]~gx.covars[,j])
    pval.pca1[i,j]=anova(data1)$'Pr(>F)'[1]
  }
}

head(pval.pca1)
```

### Regress out RIN

* PCA for the second time:

```{r regress_out_rin, echo = FALSE}
r.residual.int = matrix(nrow= nrow(my_data), ncol = ncol(my_data))
rownames(r.residual.int) = rownames(my_data)
colnames(r.residual.int) = colnames(my_data)
for (i in 1:nrow(my_data)) {
  model.i= lm(my_data[i,]~ gx.covars[,4])
  r.residual.int[i,] = resid(model.i) + model.i$coefficients[1]
}

sum.PC <- prcomp(t(r.residual.int), scale=FALSE, center=TRUE)
sumsum <- summary(sum.PC)
prop.var<-sumsum$importance
prop.var[1:3,1:20] 
title.PC<-"PCA 2"

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca1=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca1)=pc_list
colnames(pval.pca1)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data2= lm(sum.PC$x[,i]~gx.covars[,j])
    pval.pca1[i,j]=anova(data2)$'Pr(>F)'[1]
  }
}

head(pval.pca1)

#plot( gx.covars$batch, sum.PC$x[,1], main="Batch by PC1")
#plot( gx.covars$batch, sum.PC$x[,5], main="Batch by PC5")

```

* RNA concentration correlated with PC1, regress that out:

### Regress out RNA concentration

```{r regress_out_rnaconcentration, echo = FALSE}
r.residual.int2 = matrix(nrow= nrow(r.residual.int), ncol = ncol(r.residual.int))
rownames(r.residual.int2) = rownames(r.residual.int)
colnames(r.residual.int2) = colnames(r.residual.int)
for (i in 1:nrow(r.residual.int)) {
  model.i= lm(r.residual.int[i,]~ gx.covars[,3])
  r.residual.int2[i,] = resid(model.i) + model.i$coefficients[1]
}

sum.PC <- prcomp(t(r.residual.int2), scale=FALSE, center=TRUE)
sumsum <- summary(sum.PC)
prop.var<-sumsum$importance
prop.var[1:3,1:20] 
title.PC<-"PCA 3 "

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca1=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca1)=pc_list
colnames(pval.pca1)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data1= lm(sum.PC$x[,i]~gx.covars[,j])
    pval.pca1[i,j]=anova(data1)$'Pr(>F)'[1]
  }
}

head(pval.pca1)

```


* Flowcell/lane next correlated covariate with PC3

##Using ComBat to regress out Flowcell/lane

```{r pcacheck_after_batch, echo = FALSE, eval=FALSE}
#source("https://bioconductor.org/biocLite.R")
#biocLite("sva")
library(sva)
my_mod = model.matrix(~1, data=gx.covars) #Use this only if you're going to protect something
batch= (gx.covars$batch)
#modcombat = model.matrix(~1, data=gx.covars)
combat_batch = ComBat(r.residual.int2, batch=batch, mod=my_mod,  par.prior=TRUE, prior.plots=FALSE)


newdata<- combat_batch
sum.PC2 <- prcomp(t(newdata), scale=TRUE, center=FALSE, na.action=na.omit)
sumsum2 <- summary(sum.PC2)
prop.var2<-sumsum2$importance
prop.var2[1:3,1:20] 
title.PC<-"PCA 4"

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca2=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca2)=pc_list
colnames(pval.pca2)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data2= lm(sum.PC2$x[,i]~gx.covars[,j])
    pval.pca2[i,j]=anova(data2)$'Pr(>F)'[1]
  }
}
head(pval.pca2)

```


* Batch next correlated covariate

###Using combat to regress out batch

```{r, correcting_batch, echo = FALSE, eval=FALSE}

my_mod = model.matrix(~1, data=gx.covars) #Use this only if you're going to protect something
batch= (gx.covars$flowlane)
#modcombat = model.matrix(~1, data=gx.covars)
combat_batch = ComBat(newdata, batch=batch, mod=my_mod,  par.prior=TRUE, prior.plots=FALSE)


newdata2<- combat_batch
sum.PC2 <- prcomp(t(newdata2), scale=TRUE, center=FALSE, na.action=na.omit)
sumsum2 <- summary(sum.PC2)
prop.var2<-sumsum2$importance
prop.var2[1:3,1:20] 
title.PC<-"PCA 4"

##To see if covariates are correlated with a PC (looking at PC1-50)
pval.pca2=matrix(ncol=ncol(gx.covars), nrow=50)
rownames(pval.pca2)=pc_list
colnames(pval.pca2)=colnames(gx.covars)

for(j in 1:ncol(gx.covars))
{
  for(i in 1:length(pc_list))
  {
    data2= lm(sum.PC2$x[,i]~gx.covars[,j])
    pval.pca2[i,j]=anova(data2)$'Pr(>F)'[1]
  }
}
head(pval.pca2)
```

* When Flowcell/Lane is regressed out, it seems that the covariate batch becomes signficantly correlated with PC3 and moreso than Flowcell/Lane was before it was regressed out. 


# 05-18-16 decided to only do TMM normalization but not regress out effects: 
# So use my_data moving forward for now.

```{r maternal and paternal, echo =FALSE, eval=FALSE}
#5-18-16 decided to only do TMM normalization but not regress out effects: 
# SO use my_data moving forward for now.
my_data<- exp(r.residual.int2)
maternal <- maternalrun1[-c(1:4),]
paternal <- paternalrun1[-c(1:4),]
#maternal<- read.table("~/star_overhang_v19_genecount_maternalaltcountReadsPerGene.out.tab", check.names = FALSE)
#paternal<- read.table("~/star_overhang_v19_genecount_paternalaltcountReadsPerGene.out.tab", check.names = FALSE)

mat <- as.matrix(maternal)
findivs <- sapply(strsplit(colnames(mat), "_"), "[", 2)
colnames(mat) <- findivs
nms <- colnames(mat)
aftersumlanemat <- as.data.frame(mat %*% sapply(unique(nms), "==", nms))
aftersumgenes <- gsub("\\..*","",rownames(aftersumlanemat))
rownames(aftersumlanemat) <- aftersumgenes 

pat <- as.matrix(paternal)
findivs <- sapply(strsplit(colnames(pat), "_"), "[", 2)
colnames(pat) <- findivs
nms <- colnames(pat)
aftersumlanepat <- as.data.frame(pat %*% sapply(unique(nms), "==", nms))
aftersumgenes <- gsub("\\..*","",rownames(aftersumlanemat))
findivs<- colnames(aftersumlanepat)
rownames(aftersumlanepat) <- aftersumgenes 


#No parent of origin information for:
colnames(my_data)[which(!colnames(my_data)%in%findivs)]
missing <- which(!colnames(my_data)%in%findivs)
#beforenames <- colsplit(string=colnames(my_data)[missing], pattern="_", names=c("FC", "findiv", "lanetext","lane"))
#findivsmissing <- beforenames$findiv

#Removed from qc:
findivs[which(!findivs%in%colnames(my_data))]
removed <- which(!findivs%in%colnames(my_data))
#beforenames <- colsplit(string=findivs[removed], pattern="_", names=c("FC", "findiv", "lanetext","lane"))
#findivstoremove <- beforenames$findiv

newer <- my_data
genes<- rownames(newer)
newmat <- aftersumlanemat[genes,-c(removed)]
newpat <- aftersumlanepat[genes,-c(removed)]
newmat2 <- newmat[,colnames(newer)]
newpat2 <- newpat[,colnames(newer)]

aftersumlaneprop <- aftersumlane[genes,colnames(newer)]

#str(newmat2)
#dim(newmat2)
#str(aftersumlaneprop)
#dim(aftersumlaneprop)

propmat <- newmat2/aftersumlaneprop
proppat <- newpat2/aftersumlaneprop

newermat2 <- log((propmat*newer))
newerpat2 <- log((proppat*newer))

newermat2[is.na(newermat2)] <- 0
newerpat2[is.na(newerpat2)] <- 0

newermat2[newermat2==-Inf] <- 0
newerpat2[newerpat2==-Inf] <- 0

write.table(newerpat2, "Paternal_gene_normalized_v19log.txt", quote =F, row.names = T, col.names = T)
write.table(newermat2, "Maternal_gene_normalized_v19log.txt", quote =F, row.names = T, col.names = T)

```

```{r unknown, echo = FALSE, eval=FALSE}
keep <- homrun1
#keep <- read.table("~/star_overhang_v19_genecount_genes_hom", check.names = F)
k <- as.matrix(keep)
findivs <- sapply(strsplit(colnames(k), "_"), "[", 2)
colnames(k) <- findivs
nms <- colnames(k)
aftersumlanekeep <- as.data.frame(k %*% sapply(unique(nms), "==", nms))
aftersumgenes <- gsub("\\..*","",rownames(aftersumlanekeep))
rownames(aftersumlanekeep) <- aftersumgenes 

findivs<- colnames(aftersumlanekeep)

#No parent of origin information for:
colnames(my_data)[which(!colnames(my_data)%in%findivs)]
missing <- which(!colnames(my_data)%in%findivs)
#beforenames <- colsplit(string=colnames(my_data)[missing], pattern="_", names=c("FC", "findiv", "lanetext","lane"))
#findivsmissing <- beforenames$findiv

#Removed from qc:
findivs[which(!findivs%in%colnames(my_data))]
removed <- which(!findivs%in%colnames(my_data))

newkeep <- aftersumlanekeep[genes,-c(removed)]
newkeep2 <- newkeep[,colnames(newer)]



aftersumlaneprop <- aftersumlane[genes,colnames(newer)]
propkeep <- newkeep2/aftersumlaneprop

newerkeep <- log(propkeep*newer)

newerkeep[is.na(newerkeep)] <- 0
newerkeep[newerkeep==-Inf] <- 0

write.table(newerkeep, "Unknown_gene_normalized_v19log.txt", quote =F, row.names = T, col.names = T)
write.table(log(newer), "Total_gene_normalized_v19log.txt", quote = F, row.names = T, col.names = T)

```



```{r imprinted, echo = FALSE, eval=FALSE}


#Imprinted Genes

imprinted <- read.table("~/Imprintedgenenames.txt")
genes<- rownames(mat)
a <- c()
imgenes<- c()
for (i in 1:dim(imprinted)[1]) {
    a <- c(a, grep(imprinted[i,1], genes))
    imgenes <- c(imgenes, i)
}
length(imgenes)

matim <- c()
patim <- c()
for(j in 1:dim(mat)[1]) {
    if (sum(mat[j,]) < 1) {
       if (sum(pat[j,]) > 5) {
          matim <- c(matim, j)
        }
    }
}
for(j in 1:dim(pat)[1]) {
    if (sum(pat[j,]) < 1) {
       if (sum(mat[j,]) > 5) {
          patim <- c(patim, j)
        }
    }
}



equal <- c()
for(j in 1:dim(mat)[1]) {
    if (sum(mat[j,]) >20) {
        if (sum(mat[j,]) == sum(pat[j,])) {
          equal <- c(equal, j)
        }
    }
}


```

